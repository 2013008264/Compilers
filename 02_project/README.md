# Project #2. Simple C minus parser.
## **Build & Sample test**

<p align=center>
<img src="https://user-images.githubusercontent.com/35682872/46450970-0c1a2d80-c7cf-11e8-8f8c-153d5c7acb11.gif"/>
</p>

<p align=center>
<img src="https://img.shields.io/badge/gcc-5.xx-green.svg"/>
<img src="https://img.shields.io/badge/dependencies-make-green.svg"/>
<img src="https://img.shields.io/badge/dependencies-flex-green.svg"/>
<img src="https://img.shields.io/badge/dependencies-bison-green.svg">
</p>

****************************
### **How to build**
You can build this parse with `make`
```bash
$ make
```

### **Build status**
|program | Ubuntu 18.04 | Windows | X OS |
|----  |   ----   | ---- | ---- |
|parser|  <img src="https://img.shields.io/badge/build-failure-red.svg"/> | <img src="https://img.shields.io/badge/build-failure-red.svg"/> | <img src="https://img.shields.io/badge/build-passing-green.svg"/>  |

### **How to generate test**
Test this parser with shell script.
```bash
$ ./test.sh
```
## **How it works?**
This is upgrade version of using-lex scanner. So, there has same dependencies with using-lex. And has another dependencies. This parser is auto generated by bison. Because of this, I make header file to use this `.c` file's heart functions. This is in `parse.h`. The core function is `TreeNode * parse(void)`. That function is called in `main.c`, and returns AST (Abstract Syntax Tree). Program is terminated, after prints returned AST.

## **Troubles..**
There was some troubles, beacause parser has dependency to my lex file. So, I changed my lex file also... 

# Korean
지난번 using-lex scanner 에서 조금 발전한 형태입니다. 그래서, 여전히 flex 에 dependency 를 갖고있습니다. 이번 parser 는 바이슨을 통해 auto generate 됩니다.  때문에, 바이슨을 통해 생성되는 `.c` 파일의 핵심적인 함수들을 사용할 수 있도록 헤더파일을 만들어야 했습니다. 이는 `parse.h` 에 있습니다. 해당 함수는 main.c 에서 호출되며, 그 함수는 AST(Abstract Syntax Tree) 를 반환합니다. 반환된 AST 를 출력해주면서 프로그램은 종료됩니다. 

## **개발하면서**
지난번 과제보다 조금 어려움이 있었다. 그 이유는 지난번 과제는 dependency 가 없었지만, 이번 parser 에서는 cminus.l 이란 내가 짠 lex 에, dependency 를 갖고있기 때문이다. 때문에 개발하면서, parser 뿐만아니라, lex 를 조금 더 사용하기 편하게 바꾸어야 하는 과정이 필요했다. 그래서 이번 과제는 yacc 뿐만 아니라, lex 를 전면적으로 고치면서, 지난번 보다 할 것이 조금 많았다. 